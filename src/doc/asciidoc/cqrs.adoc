:description: CQRS in Theorie und praktisch mit dem Axon Framework
:backend: revealjs
:author: Christian Iwanzik
:twitter: chrisIwanzik
:revealjs_theme: default
:customcss: ./cqrs.css

= CQRS

Command Query Responsibility Segregation

== Bauen wir einen Customer Service!

[source,kotlin]
----
include::{sourcedir}/kotlin/de/tarent/crud/one/CustomerCrud.kt[tags=presentation]
----

[NOTE.speaker]
--
Good old CRUD. Lediglich ein Modell und einige Methoden. Warum dann nicht direkt eine noSQL DB?
--

=== ... und dann kamen die Anforderungen

Hm. Die UUID soll bei der Registrierung erzeugt werden.

[source,kotlin]
----
include::{sourcedir}/kotlin/de/tarent/crud/two/CustomerUuidGenerator.kt[tags=presentation]
----

[NOTE.speaker]
--
Oh je. Unser schönes CRUD wird aufgelöst. Statt einem zentralen Modell haben wir plötzlich
schon zwei verschiedene.
--

[%notitle]
=== ... noch mehr Anforderungen

Oh, die Email darf nicht mehr einfach so einfach geändert werden...

[source,kotlin]
----
include::{sourcedir}/kotlin/de/tarent/crud/three/CustomerEmailOptin.kt[tags=presentation2]
----

[source,kotlin]
----
include::{sourcedir}/kotlin/de/tarent/crud/three/CustomerEmailOptin.kt[tags=presentation1]
----

[NOTE.speaker]
--
Und schon ist es mit CRUD am Ende. Allein das die Email über ein Double-Optin geschehen muss,
zwingt uns zu einem "Zwischenstand" im Modell.
--

[transition=fast]
=== Ist CRUD noch das Mittel der Wahl?
image::crud.svg[background, size=cover]

[NOTE.speaker]
--
Das war mal ein schönes Modell und ein guter Anfang.
--

[transition=fast]
=== Ist CRUD noch das Mittel der Wahl?
image::crudExploded.svg[background, size=cover]

[NOTE.speaker]
--
Aber sehr schnell schleicht sich die Komplexität in die Applikation.
--

[transition=fast]
=== Aus der Praxis:
image::thunderbirdsPayback.jpg[background, size=cover]

[NOTE.speaker]
--
Reales Beispiel mit ausufernder Komplexität.
--

== Divide and Conquer oder... CRQS
image::crudArchitecture.svg[background, size=cover]

[NOTE.speaker]
--
Bei CRUD und ähnlichen Architekturen laufen die ändernden und abrufenden
Anfragen meist durch das selbe Modell, bzw. Schichten.
Dieses Modell muss dann aber auch alle Anforderungen erfüllen was die
Komplexität schnell in die Höhe treiben kann.
--

=== CQRS als Alternative
image::cqrsArchitecture.svg[background, size=cover]

[NOTE.speaker]
--
Bei CQRS sind ändernde und abrufende Anfragen strikt getrennt.
Bei Änderungen werden nicht die gesamten Daten überschrieben, sondern nur partielle
`Commands` angewendet.
Auf der Abfrageebene wird das Hauptmodell in Querymodelle überführt. Dadurch lassen sich
spezifische Abfragen besser steuern. Das Querymodell könnte z.B. eine Submenge oder eine
zusammengeführte Menge aus mehreren Modellen sein.
--

=== Event Sourceing als Erweiterung
image::eventSourcingSimple.svg[background, size=cover]

[NOTE.speaker]
--
Mit Event Sourcing gibt es eine gute Erweiterung, welche die Kopplung noch weiter
aufweicht.
--

== Axon - Livedemo

== Quellen
* https://martinfowler.com/bliki/CQRS.html
* http://codebetter.com/gregyoung/2010/02/16/cqrs-task-based-uis-event-sourcing-agh/
* https://martinfowler.com/eaaDev/EventSourcing.html
