:description: CQRS in Theorie und praktisch mit dem Axon Framework
:backend: revealjs
:author: Christian Iwanzik
:twitter: chrisIwanzik
:revealjs_theme: default
:customcss: ./cqrs.css

= CQRS

Command Query Responsibility Segregation

== Bauen wir einen Customer Service!

[source,kotlin]
----
include::{sourcedir}/kotlin/de/tarent/crud/one/CustomerCrud.kt[tags=presentation]
----

[NOTE.speaker]
--
Good old CRUD. Lediglich ein Modell und einige Methoden. Warum dann nicht direkt eine noSQL DB?
--

=== ... und dann kamen die Anforderungen

Hm. Die UUID soll bei der Registrierung erzeugt werden.

[source,kotlin]
----
include::{sourcedir}/kotlin/de/tarent/crud/two/CustomerUuidGenerator.kt[tags=presentation]
----

[NOTE.speaker]
--
Oh je. Unser schönes CRUD wird aufgelöst. Statt einem zentralen Modell haben wir plötzlich
schon zwei verschiedene.
--

[%notitle]
=== ... noch mehr Anforderungen

Oh, die Email darf nicht mehr einfach so einfach geändert werden...

[source,kotlin]
----
include::{sourcedir}/kotlin/de/tarent/crud/three/CustomerEmailOptin.kt[tags=presentation2]
----

[source,kotlin]
----
include::{sourcedir}/kotlin/de/tarent/crud/three/CustomerEmailOptin.kt[tags=presentation1]
----

[NOTE.speaker]
--
Und schon ist es mit CRUD am Ende. Allein das die Email über ein Double-Optin geschehen muss,
zwingt uns zu einem "Zwischenstand" im Modell.
--

=== Ist CRUD noch das Mittel der Wahl?
Wir kamen von hier:

image::crud.svg[size=cover]

[NOTE.speaker]
--
Das war mal ein schönes Modell und ein guter Anfang.
--

=== Ist CRUD noch das Mittel der Wahl?
Und sind mittlerweile hier:

image::crudExploded.svg[size=cover]

[NOTE.speaker]
--
Aber sehr schnell schleicht sich die Komplexität in die Applikation.
--

=== Big ball of mud:
Und so kann es irgendwann aussehen:

image::thunderbirdsPayback.jpg[600,600]]

[NOTE.speaker]
--
Reales Beispiel mit ausufernder Komplexität.
--

== Divide and Conquer oder... CQRS
image::crudArchitecture.svg[background, size=cover]

[NOTE.speaker]
--
Bei CRUD und ähnlichen Architekturen laufen die ändernden und abrufenden
Anfragen meist durch das selbe Modell, bzw. Schichten.
Dieses Modell muss dann aber auch alle Anforderungen erfüllen was die
Komplexität schnell in die Höhe treiben kann.
--

=== CQRS als Alternative
image::cqrsArchitecture.svg[background, size=cover]

[NOTE.speaker]
--
Bei CQRS sind ändernde und abrufende Anfragen strikt getrennt.
Bei Änderungen werden nicht die gesamten Daten überschrieben, sondern nur partielle
`Commands` angewendet.
Auf der Abfrageebene wird das Hauptmodell in Querymodelle überführt. Dadurch lassen sich
spezifische Abfragen besser steuern. Das Querymodell könnte z.B. eine Submenge oder eine
zusammengeführte Menge aus mehreren Modellen sein.
--

=== Was sind Commands?

image::commandTransition.jpg[]

[source,kotlin]
----
include::{sourcedir}/kotlin/de/tarent/cqrs/Commands.kt[tags=presentation]
----

=== Was sind Queries?

== Events als Erweiterung
image::eventSourcingSimple.svg[background, size=cover]

[NOTE.speaker]
--
Mit Event Sourcing gibt es eine gute Erweiterung, welche die Kopplung noch weiter
aufweicht.
--

=== Events

=== Command -> Model -> Event
[NOTE.speaker]
--
Commands ändern das Modell/Domäne und diese erzeugen wiederum Events.
--


=== Event -> Model -> Query
[NOTE.speaker]
--
EventHandler verarbeiten Events und ändern ihr eigenes Querymodell.
Events können dabei aus verschiedenen Quellen, bzw. CommandModellen stammen.
--

== Das Axon Framework

=== Architektur

== Quellen
* https://martinfowler.com/bliki/CQRS.html
* http://codebetter.com/gregyoung/2010/02/16/cqrs-task-based-uis-event-sourcing-agh/
* https://martinfowler.com/eaaDev/EventSourcing.html
